import 'package:equatable/equatable.dart';

/// Payment attempt model for tracking payment processes
class PaymentAttempt extends Equatable {
  const PaymentAttempt({
    this.id,
    required this.invoiceId,
    required this.attemptDate,
    required this.amount,
    required this.referenceId,
    required this.status,
    required this.paymentMethod,
    this.notes,
    this.errorMessage,
    this.providerTransactionId,
    this.createdAt,
  });

  /// Payment attempt ID (auto-generated UUID)
  final String? id;

  /// Invoice ID this attempt is for
  final String invoiceId;

  /// Date/time when payment attempt was made
  final DateTime attemptDate;

  /// Amount attempted to be paid
  final double amount;

  /// Reference ID for tracking (generated by app)
  final String referenceId;

  /// Current status of the payment attempt
  final PaymentAttemptStatus status;

  /// Payment method used
  final PaymentMethod paymentMethod;

  /// Optional notes or additional information
  final String? notes;

  /// Error message if payment failed
  final String? errorMessage;

  /// Transaction ID from payment provider (if available)
  final String? providerTransactionId;

  /// Attempt creation timestamp
  final DateTime? createdAt;

  /// Check if attempt was successful
  bool get isSuccessful => status == PaymentAttemptStatus.success;

  /// Check if attempt failed
  bool get isFailed => status == PaymentAttemptStatus.failed;

  /// Check if attempt is pending
  bool get isPending => status == PaymentAttemptStatus.pending;

  /// Create PaymentAttempt from JSON (Supabase response)
  factory PaymentAttempt.fromJson(Map<String, dynamic> json) {
    return PaymentAttempt(
      id: json['id'] as String?,
      invoiceId: json['invoice_id'] as String,
      attemptDate: DateTime.parse(json['attempt_date'] as String),
      amount: (json['amount'] as num).toDouble(),
      referenceId: json['reference_id'] as String,
      status: PaymentAttemptStatus.fromString(json['status'] as String),
      paymentMethod: PaymentMethod.fromString(json['payment_method'] as String),
      notes: json['notes'] as String?,
      errorMessage: json['error_message'] as String?,
      providerTransactionId: json['provider_transaction_id'] as String?,
      createdAt: json['created_at'] != null
          ? DateTime.parse(json['created_at'] as String)
          : null,
    );
  }

  /// Convert PaymentAttempt to JSON (for Supabase operations)
  Map<String, dynamic> toJson() {
    return {
      if (id != null) 'id': id,
      'invoice_id': invoiceId,
      'attempt_date': attemptDate.toIso8601String(),
      'amount': amount,
      'reference_id': referenceId,
      'status': status.value,
      'payment_method': paymentMethod.value,
      'notes': notes,
      'error_message': errorMessage,
      'provider_transaction_id': providerTransactionId,
      if (createdAt != null) 'created_at': createdAt!.toIso8601String(),
    };
  }

  /// Create a new payment attempt for PhonePe
  factory PaymentAttempt.createPhonePeAttempt({
    required String invoiceId,
    required double amount,
    required String referenceId,
    String? notes,
  }) {
    return PaymentAttempt(
      invoiceId: invoiceId,
      attemptDate: DateTime.now(),
      amount: amount,
      referenceId: referenceId,
      status: PaymentAttemptStatus.initiated,
      paymentMethod: PaymentMethod.phonepe,
      notes: notes,
    );
  }

  /// Create a copy with updated fields
  PaymentAttempt copyWith({
    String? id,
    String? invoiceId,
    DateTime? attemptDate,
    double? amount,
    String? referenceId,
    PaymentAttemptStatus? status,
    PaymentMethod? paymentMethod,
    String? notes,
    String? errorMessage,
    String? providerTransactionId,
    DateTime? createdAt,
  }) {
    return PaymentAttempt(
      id: id ?? this.id,
      invoiceId: invoiceId ?? this.invoiceId,
      attemptDate: attemptDate ?? this.attemptDate,
      amount: amount ?? this.amount,
      referenceId: referenceId ?? this.referenceId,
      status: status ?? this.status,
      paymentMethod: paymentMethod ?? this.paymentMethod,
      notes: notes ?? this.notes,
      errorMessage: errorMessage ?? this.errorMessage,
      providerTransactionId: providerTransactionId ?? this.providerTransactionId,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  List<Object?> get props => [
        id,
        invoiceId,
        attemptDate,
        amount,
        referenceId,
        status,
        paymentMethod,
        notes,
        errorMessage,
        providerTransactionId,
        createdAt,
      ];
}

/// Payment attempt status enumeration
enum PaymentAttemptStatus {
  initiated('initiated'),
  pending('pending'),
  success('success'),
  failed('failed'),
  cancelled('cancelled'),
  timeout('timeout');

  const PaymentAttemptStatus(this.value);

  final String value;

  /// Create PaymentAttemptStatus from string value
  static PaymentAttemptStatus fromString(String value) {
    switch (value.toLowerCase()) {
      case 'initiated':
        return PaymentAttemptStatus.initiated;
      case 'pending':
        return PaymentAttemptStatus.pending;
      case 'success':
        return PaymentAttemptStatus.success;
      case 'failed':
        return PaymentAttemptStatus.failed;
      case 'cancelled':
        return PaymentAttemptStatus.cancelled;
      case 'timeout':
        return PaymentAttemptStatus.timeout;
      default:
        throw ArgumentError('Invalid payment attempt status: $value');
    }
  }

  /// Display name for the status
  String get displayName {
    switch (this) {
      case PaymentAttemptStatus.initiated:
        return 'Initiated';
      case PaymentAttemptStatus.pending:
        return 'Pending';
      case PaymentAttemptStatus.success:
        return 'Success';
      case PaymentAttemptStatus.failed:
        return 'Failed';
      case PaymentAttemptStatus.cancelled:
        return 'Cancelled';
      case PaymentAttemptStatus.timeout:
        return 'Timeout';
    }
  }

  /// Color hex code for status display
  String get colorHex {
    switch (this) {
      case PaymentAttemptStatus.initiated:
        return '#2196F3'; // Blue
      case PaymentAttemptStatus.pending:
        return '#FF9800'; // Orange
      case PaymentAttemptStatus.success:
        return '#4CAF50'; // Green
      case PaymentAttemptStatus.failed:
        return '#F44336'; // Red
      case PaymentAttemptStatus.cancelled:
        return '#9E9E9E'; // Grey
      case PaymentAttemptStatus.timeout:
        return '#FF5722'; // Deep Orange
    }
  }

  /// Icon name for status display
  String get iconName {
    switch (this) {
      case PaymentAttemptStatus.initiated:
        return 'launch';
      case PaymentAttemptStatus.pending:
        return 'pending';
      case PaymentAttemptStatus.success:
        return 'check_circle';
      case PaymentAttemptStatus.failed:
        return 'error';
      case PaymentAttemptStatus.cancelled:
        return 'cancel';
      case PaymentAttemptStatus.timeout:
        return 'schedule';
    }
  }
}

/// Payment method enumeration
enum PaymentMethod {
  phonepe('phonepe'),
  upi('upi'),
  netbanking('netbanking'),
  card('card'),
  cash('cash'),
  cheque('cheque'),
  other('other');

  const PaymentMethod(this.value);

  final String value;

  /// Create PaymentMethod from string value
  static PaymentMethod fromString(String value) {
    switch (value.toLowerCase()) {
      case 'phonepe':
        return PaymentMethod.phonepe;
      case 'upi':
        return PaymentMethod.upi;
      case 'netbanking':
        return PaymentMethod.netbanking;
      case 'card':
        return PaymentMethod.card;
      case 'cash':
        return PaymentMethod.cash;
      case 'cheque':
        return PaymentMethod.cheque;
      case 'other':
        return PaymentMethod.other;
      default:
        throw ArgumentError('Invalid payment method: $value');
    }
  }

  /// Display name for the payment method
  String get displayName {
    switch (this) {
      case PaymentMethod.phonepe:
        return 'PhonePe';
      case PaymentMethod.upi:
        return 'UPI';
      case PaymentMethod.netbanking:
        return 'Net Banking';
      case PaymentMethod.card:
        return 'Card';
      case PaymentMethod.cash:
        return 'Cash';
      case PaymentMethod.cheque:
        return 'Cheque';
      case PaymentMethod.other:
        return 'Other';
    }
  }

  /// Color hex code for payment method display
  String get colorHex {
    switch (this) {
      case PaymentMethod.phonepe:
        return '#5F2D91'; // PhonePe Purple
      case PaymentMethod.upi:
        return '#FF9800'; // Orange
      case PaymentMethod.netbanking:
        return '#2196F3'; // Blue
      case PaymentMethod.card:
        return '#4CAF50'; // Green
      case PaymentMethod.cash:
        return '#795548'; // Brown
      case PaymentMethod.cheque:
        return '#607D8B'; // Blue Grey
      case PaymentMethod.other:
        return '#9E9E9E'; // Grey
    }
  }

  /// Icon name for payment method display
  String get iconName {
    switch (this) {
      case PaymentMethod.phonepe:
        return 'smartphone';
      case PaymentMethod.upi:
        return 'account_balance';
      case PaymentMethod.netbanking:
        return 'web';
      case PaymentMethod.card:
        return 'credit_card';
      case PaymentMethod.cash:
        return 'money';
      case PaymentMethod.cheque:
        return 'receipt_long';
      case PaymentMethod.other:
        return 'payment';
    }
  }

  /// Whether this payment method supports automatic status updates
  bool get supportsAutoStatus {
    switch (this) {
      case PaymentMethod.phonepe:
      case PaymentMethod.upi:
      case PaymentMethod.netbanking:
      case PaymentMethod.card:
        return true;
      case PaymentMethod.cash:
      case PaymentMethod.cheque:
      case PaymentMethod.other:
        return false;
    }
  }
}

/// PhonePe payment utilities
class PhonePeUtils {
  const PhonePeUtils._();

  /// Generate PhonePe payment deeplink
  static String generateDeeplink({
    required String merchantId,
    required String transactionId,
    required double amount,
    String? merchantUserId,
    String? callbackUrl,
  }) {
    final amountInPaise = (amount * 100).toInt();
    
    // Basic PhonePe deeplink format
    final params = [
      'trid=$transactionId',
      'amount=$amountInPaise',
      'muid=${merchantUserId ?? 'USER001'}',
      'mid=$merchantId',
    ];
    
    if (callbackUrl != null) {
      params.add('callback=$callbackUrl');
    }
    
    return 'phonepe://pay?${params.join('&')}';
  }

  /// Generate UPI intent for PhonePe
  static String generateUpiIntent({
    required String merchantVpa,
    required String transactionId,
    required double amount,
    String? merchantName,
    String? note,
  }) {
    final params = [
      'pa=$merchantVpa',
      'pn=${merchantName ?? 'Merchant'}',
      'tr=$transactionId',
      'am=$amount',
      'cu=INR',
    ];
    
    if (note != null) {
      params.add('tn=${Uri.encodeComponent(note)}');
    }
    
    return 'upi://pay?${params.join('&')}';
  }

  /// Generate reference ID for payment
  static String generateReferenceId({String prefix = 'TXN'}) {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final random = DateTime.now().microsecond;
    return '${prefix}_${timestamp}_$random';
  }

  /// Validate PhonePe transaction ID format
  static bool isValidTransactionId(String transactionId) {
    if (transactionId.isEmpty || transactionId.length < 5 || transactionId.length > 35) {
      return false;
    }
    
    // Should contain only alphanumeric characters and underscores
    final regex = RegExp(r'^[a-zA-Z0-9_]+$');
    return regex.hasMatch(transactionId);
  }

  /// Format amount for display
  static String formatAmount(double amount) {
    return '₹${amount.toStringAsFixed(2)}';
  }

  /// Parse amount from string
  static double parseAmount(String amountStr) {
    final cleanStr = amountStr.replaceAll(RegExp(r'[^\d.]'), '');
    return double.tryParse(cleanStr) ?? 0.0;
  }
}

/// Payment attempt summary for analytics
class PaymentAttemptSummary extends Equatable {
  const PaymentAttemptSummary({
    required this.totalAttempts,
    required this.successfulAttempts,
    required this.failedAttempts,
    required this.pendingAttempts,
    required this.totalAmount,
    required this.successAmount,
    required this.failureRate,
  });

  final int totalAttempts;
  final int successfulAttempts;
  final int failedAttempts;
  final int pendingAttempts;
  final double totalAmount;
  final double successAmount;
  final double failureRate;

  /// Success rate as percentage
  double get successRate => totalAttempts > 0 ? (successfulAttempts / totalAttempts) * 100 : 0.0;

  /// Average attempt amount
  double get averageAmount => totalAttempts > 0 ? totalAmount / totalAttempts : 0.0;

  @override
  List<Object?> get props => [
        totalAttempts,
        successfulAttempts,
        failedAttempts,
        pendingAttempts,
        totalAmount,
        successAmount,
        failureRate,
      ];
}